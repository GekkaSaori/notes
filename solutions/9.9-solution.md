
## 9.8-9.9 solutions - multi-school test & nowcoder #172
Contest #2 传送门：[link](https://www.nowcoder.com/acm/contest/172#question)

### summary

时间安排还是不合理。部分分都没有拿到。容易题没有思路，惨死了。

题目比较难，但是还是有部分分可以拿。考挂自己菜。

最后 15 分钟一定什么都不能做了。这个时候大脑已经处于混乱状态，作出的决策极有可能是错误的。

### Day 1 Task A

给一个数列 $a$，求对于数列中的每一项，数列中有多少个数（自己本身不算）为它的约数。

#### Error

原题目很难读懂，花了半个小时读题。

这题我进行了数据分治。但是在最后 5 分钟内将枚举边界改错了（为什么要枚举到第 $\sqrt{\max a_i}$ 个数啊，一点逻辑性也没有）。

还是数学知识缺乏与基本功的不扎实。

#### Solution

注意到 $a_i$ 的值比较小。我们可以开个桶，记录下每个数的出现次数，然后枚举数列中的每个数，更新它所有的倍数，最后把它自己删掉即可。复杂度分析不会，用到调和级数之类的东西。但总之能过，事实上复杂度是 $O(n\log_2n)$。

### Day 1 Task B

给一个字符串，找一个区间使得出现次数最多的字符与出现次数最少的字符出现次数之差最大。

#### Error

为什么 RE 了啊？同样是在 Windows 下测，真的不知道为什么。

#### Solution

这种题目很明显是要进行 DP 的，考场上也想到了。设 $dp[i][j]$ 表示当前考虑到了第 $i$ 位，当前字母为 $j$ 的出现次数。那么答案就是某个 $(dp[r][y]-dp[l-1][y])-(dp[r][z]-dp[l-1][z])$。换一种写法，按枚举的端点分类，我们可以得到答案为 $(dp[r][y]-dp[r][z])-(dp[l-1][y]-dp[l-1][z])$。这样的话我们可以在 $O(n)$ 的时间内预处理出 $dp[l-1][y]-dp[l-1][z]$ 的最小值（常数为 26），对于每个右端点 $r$，我们找到原来的字符，找到 $dp[r][ch]$，枚举一个字母作为左端点（常数为 26），然后找到最小值更新答案。

### Day 1 Task C

给一张图，删去最短路中直接与每个结点相连的一条边，再跑一次最短路，求新的最短路的长度。

#### Error

为什么 CE 了？SB 的我把改了没编译的暴力交上去了。为什么只有 20 分而不是 30？我用了邻接矩阵存的图，如果用邻接链表存图应该会获得比较优秀的常数吧。

还是不能慌张，遇到自己熟悉的东西可以考虑（比如说如果用 `vector` 存一个迭代器指向直接连接到每个点的最后一条边就可以了，边权改成无穷大然后特判一下边权之类的都可以）。

#### Solution

其实对于每一个点，跑一次最短路就知道要删掉的那条边都是被钦定了的。我们当然不能模拟删掉这一条边然后重新跑一次最短路，太浪费了吧。我们注意到对于每个点最短路是唯一的，也就是说，我们可以构成一棵唯一的最短路树，并且删掉这一条边后这棵树就不能联通了。我们观察可以发现，对于每个点在最短路树上只会被经过一次。那么我们可以将问题稍微抽象一下，对于每一个点，删一条边并不会改变其之前的任何边，即权值没有变化，我们需要将一条链上的权值更新为 $x$，并且查询某一个点的权值。保证所有后一种操作在前一种操作之后。那么我们就可以跑树链剖分了。

### Day 2 Task A
给一个数列，求一个长度大于等于 $k$ 的区间，使得其中位数最大。
#### Error
考场上想到了一个错误的结论。即对于一个长度大于等于 $k$ 的区间，如果存在一个长度为 $k$ 的区间，使得其中位数最大，那么其它长度大于等于 $k$ 的区间的中位数一定小于等于这个值。

很明显可以发现这个结论是有问题的。

#### Solution

我们考虑二分一个值，然后给区间大于这个值的数标记为 1，给小于这个值的数标记为 -1，检验是否存在一个区间满足要求。这样做是 $O(n^2\log_2\max a_i)$ 的。我们考虑维护一个前缀和，维护前缀最大值，然后 $O(n)$ 判断前缀和中是否存在满足大于 0 的项即可。时间复杂度 $O(n\log_2\max A_i)$
30%
直接枚举合法长度的区间。然后分别求每个区间的中位数。
#### 60%
用主席树维护动态区间 $k$ 大即可。

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEwNTU0ODMwNThdfQ==
-->